:py:mod:`neural_compressor.adaptor.tf_utils.quantize_graph.qat.quantize_wrapper`
================================================================================

.. py:module:: neural_compressor.adaptor.tf_utils.quantize_graph.qat.quantize_wrapper

.. autoapi-nested-parse::

   QAT Quantize Wrapper Class.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   neural_compressor.adaptor.tf_utils.quantize_graph.qat.quantize_wrapper.QuantizeWrapperBase
   neural_compressor.adaptor.tf_utils.quantize_graph.qat.quantize_wrapper.QuantizeWrapper




.. py:class:: QuantizeWrapperBase(layer, **kwargs)

   Bases: :py:obj:`tensorflow.keras.layers.Wrapper`

   Base class for quantize wrapper.

   .. py:property:: trainable

      Get trainable attribute for the layer and its sublayers.

   .. py:property:: trainable_weights

      List of all trainable weights tracked by this layer.

      Trainable weights are updated via gradient descent during training.

      :returns: A list of trainable variables.
      :rtype: trainable_weights (list)

   .. py:property:: non_trainable_weights

      List of all non-trainable weights tracked by this layer.

      Non-trainable weights are *not* updated during training. They are
      expected to be updated manually in `call()`.

      :returns: A list of non-trainable variables.
      :rtype: non_trainable_weights (list)

   .. py:property:: updates

      Update layer.

   .. py:property:: losses

      List of losses added using the `add_loss()` API.

      Variable regularization tensors are created when this property is
      accessed, so it is eager safe: accessing `losses` under a
      `tf.GradientTape` will propagate gradients back to the corresponding
      variables.

      :returns: A list of tensors.
      :rtype: losses (list)

   .. py:method:: build(input_shape)

      Creates the variables of the layer.

      :param input_shape: shapes of input tensors
      :type input_shape: tf.TensorShape or list


   .. py:method:: compute_output_shape(input_shape)

      Computes the output shape of the layer.

      This method will cause the layer's state to be built, if that has not
      happened before. This requires that the layer will later be used with
      inputs that match the input shape provided here.

      :param input_shape: input shape of the layer.
      :type input_shape: tuple of integers or tf.TensorShape

      :returns: output shape of the layer.
      :rtype: output_shape(tf.TensorShape)


   .. py:method:: query_input_index()

      Query QuantizeConfig to check if there is any designated input index for this layer.


   .. py:method:: call(inputs, training=None)
      :abstractmethod:

      This is where the quantize wrapper's logic lives.

      :param inputs: Inputs of the wrapped layer.
      :type inputs: tf.Tensor or dict/list/tuple

      :returns: Outputs of the wrapped layer.
      :rtype: outputs (tf.Tensor or dict/list/tuple)


   .. py:method:: get_config()

      Get the config of the quantize wrapper.

      :returns: dict of wrapper config.
      :rtype: config (dict)


   .. py:method:: from_config(config)
      :classmethod:

      Creates a quantize wrapper instance from its config.

      :param config: A Python dictionary, typically the output of get_config.
      :type config: dict

      :returns: (QuantizeWrapperBase): A quantize wrapper instance.
      :rtype: output_obj



.. py:class:: QuantizeWrapper(layer, **kwargs)

   Bases: :py:obj:`QuantizeWrapperBase`

   General QuantizeWrapper for quantizable layers.

   Weights and inputs will be quantized according to the layer type and quantize config.

   .. py:method:: build(input_shape)

      Creates the variables of the layer.

      :param input_shape: shapes of input tensors
      :type input_shape: tf.TensorShape or list


   .. py:method:: call(inputs, training=None)

      This is where the quantize wrapper's logic lives.

      :param inputs: Inputs of the wrapped layer.
      :type inputs: tf.Tensor or dict/list/tuple

      :returns: Outputs of the wrapped layer.
      :rtype: outputs (tf.Tensor or dict/list/tuple)



